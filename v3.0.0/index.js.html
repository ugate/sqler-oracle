<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="sqler-oracle"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 29.26 29.26" y="0px" x="0px" version="1.1">
<g>
	<path
   d="M 3.2714844 12.164062 C 3.0504844 12.547062 2.921875 12.944422 2.921875 13.357422 L 2.921875 16.919922 C 2.921875 19.670922 8.1639531 21.902344 14.626953 21.902344 C 21.093953 21.902344 26.337891 19.670922 26.337891 16.919922 L 26.337891 13.357422 C 26.337891 12.944422 26.207375 12.547062 25.984375 12.164062 C 25.170706 13.571962 22.944745 14.736211 19.992188 15.388672 C 19.990472 16.830619 19.968304 18.235467 19.923828 18.3125 C 19.831308 18.472746 14.767068 21.396484 14.582031 21.396484 C 14.396995 21.396484 9.3327528 18.472746 9.2402344 18.3125 C 9.1955638 18.235128 9.175362 16.819813 9.1738281 15.371094 C 6.2660228 14.715075 4.0769893 13.558477 3.2714844 12.164062 z "
   />
	<path
   d="M14.627,23.31c-5.494,0-10.098-1.616-11.355-3.788c-0.221,0.381-0.35,0.779-0.35,1.191v3.564   c0,2.752,5.242,4.983,11.705,4.983c6.467,0,11.711-2.23,11.711-4.983v-3.564c0-0.412-0.131-0.81-0.354-1.19   C24.727,21.694,20.127,23.31,14.627,23.31z"
   />
	<path
   d="M 3.2402344 5.0429688 C 3.0392344 5.4089688 2.921875 5.7905937 2.921875 6.1835938 L 2.921875 9.7441406 C 2.921875 11.658469 5.4621005 13.319742 9.1816406 14.154297 C 9.1905174 13.111949 9.205954 12.203907 9.2402344 12.144531 C 9.3327524 11.984284 14.396995 9.0605469 14.582031 9.0605469 C 14.767068 9.0605469 19.83131 11.984284 19.923828 12.144531 C 19.958305 12.204246 19.975593 13.121262 19.984375 14.171875 C 23.754868 13.344294 26.337891 11.674559 26.337891 9.7441406 L 26.337891 6.1835938 C 26.337891 5.7905938 26.218578 5.4099687 26.017578 5.0429688 C 25.787578 7.0589688 20.785953 8.671875 14.626953 8.671875 C 8.4709531 8.671875 3.4692344 7.0579688 3.2402344 5.0429688 z "
   />
	<path
   d="M14.627,7.541c6.303,0,11.41-1.687,11.41-3.771c0-2.082-5.107-3.77-11.41-3.77   C8.328,0.001,3.219,1.689,3.219,3.771C3.219,5.854,8.328,7.541,14.627,7.541z"
   />
</g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">sqler-oracle</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/sqler-oracle" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://ugate.github.io/sqler-oracle/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/sqler-oracle.git" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v3.0.0"
    data-jsdocp-version-base="/sqler-oracle"
    data-jsdocp-json-url="/sqler-oracle/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="3.0.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-manual.html">Getting Started</a></li><li class="nav-item"><a href="tutorial-2-usage.html">Usage</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="OracleDialect.html">OracleDialect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#beginTransaction">beginTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#exec">exec</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#getConnection">getConnection</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#init">init</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const DBDriver = require('oracledb');
const Stream = require('stream');
const typedefs = require('sqler/typedefs');

/**
 * Oracle database {@link Dialect} implementation for [`sqler`](https://ugate.github.io/sqler/)
 */
class OracleDialect {

  /**
   * Constructor
   * @constructs OracleDialect
   * @param {typedefs.SQLERPrivateOptions} priv The private configuration options
   * @param {OracleConnectionOptions} connConf The individual SQL __connection__ configuration for the given dialect that was passed into the originating {@link Manager}
   * @param {typedefs.SQLERTrack} track Container for sharing data between {@link Dialect} instances.
   * @param {Function} [errorLogger] A function that takes one or more arguments and logs the results as an error (similar to `console.error`)
   * @param {Function} [logger] A function that takes one or more arguments and logs the results (similar to `console.log`)
   * @param {Boolean} [debug] A flag that indicates the dialect should be run in debug mode (if supported)
   */
  constructor(priv, connConf, track, errorLogger, logger, debug) {
    const dlt = internal(this);
    dlt.at.track = track;
    dlt.at.transactions = new Map();
    // sqler compatible state
    dlt.at.state = {
      connections: {
        count: 0,
        inUse: 0
      },
      pending: 0
    };

    dlt.at.driver = DBDriver;

    const hasDrvrOpts = !!connConf.driverOptions;
    const dopts = hasDrvrOpts &amp;&amp; connConf.driverOptions.global;
    if (dopts) dlt.at.track.interpolate(dlt.at.driver, dopts);
    // default autoCommit = true to conform to sqler
    dlt.at.driver.autoCommit = true;
    dlt.at.driver.connectionClass = dlt.at.driver.connectionClass || `SqlerOracleGen${Math.floor(Math.random() * 10000)}`;

    /** @type {DBDriver.PoolAttributes} */
    const poolOpts = connConf.pool || {};
    const alias = poolOpts.alias || `sqlerOracleGen${Math.floor(Math.random() * 10000)}`;
    dlt.at.errorLogger = errorLogger;
    dlt.at.logger = logger;
    dlt.at.debug = debug;
    dlt.at.pool = {
      alias,
      conf: poolOpts,
      oracleConf: hasDrvrOpts &amp;&amp; connConf.driverOptions.pool ? dlt.at.track.interpolate({}, connConf.driverOptions.pool, dlt.at.driver) : {}
    };
    dlt.at.pingOnInit = hasDrvrOpts &amp;&amp; connConf.driverOptions.hasOwnProperty('pingOnInit') ? !!connConf.driverOptions.pingOnInit : true;
    dlt.at.connConf = connConf;

    dlt.at.pool.oracleConf.user = priv.username;
    dlt.at.pool.oracleConf.password = priv.password;
  
    const url = {
      host: connConf.host, // host will be defaulted to priv.host by sqler
      port: connConf.port || priv.port || 1521,
      protocol: connConf.protocol || priv.protocol || 'TCP'
    };
    if (!url.host) throw new Error(`sqler-oracle: Missing ${connConf.dialect} "host" for conection ${connConf.id}/${connConf.name} in private configuration options or connection configuration options`);

    if (connConf.service) {
      if (hasDrvrOpts &amp;&amp; connConf.driverOptions.useTNS) {
        //process.env.TNS_ADMIN = priv.privatePath;
        //dlt.at.tns = Path.join(process.env.TNS_ADMIN, 'tnsnames.ora');
        dlt.at.pool.oracleConf.connectString = `(DESCRIPTION = (ADDRESS = (PROTOCOL = ${url.protocol})(HOST = ${url.host})(PORT = ${url.port}))` +
        `(CONNECT_DATA = (SERVER = POOLED)(SERVICE_NAME = ${connConf.service})))`;
        dlt.at.connectionType = 'TNS_SERVICE';
      } else {
        dlt.at.pool.oracleConf.connectString = `${url.host}:${url.port}/${connConf.service}`;
        dlt.at.connectionType = 'SERVICE';
      }
    } else throw new Error(`sqler-oracle: Missing ${connConf.dialect} "service" for conection ${connConf.id}/${connConf.name} in connection configuration options`);
    dlt.at.pool.oracleConf.poolMin = poolOpts.min;
    dlt.at.pool.oracleConf.poolMax = poolOpts.max;
    dlt.at.pool.oracleConf.poolTimeout = poolOpts.idle;
    dlt.at.pool.oracleConf.poolIncrement = poolOpts.increment;
    dlt.at.pool.oracleConf.queueTimeout = poolOpts.timeout;
    dlt.at.pool.oracleConf.poolAlias = alias;
  }

  /**
   * Initializes {@link OracleDialect} by creating the connection pool
   * @param {typedefs.SQLERInitOptions} opts The options described by the `sqler` module
   * @returns {Object} The Oracle connection pool
   */
  async init(opts) {
    const dlt = internal(this), numSql = opts.numOfPreparedFuncs;
    statementCacheSize(dlt, numSql);
    /** @type {InternalFlightRecorder} */
    let recorder;
    /** @type {DBDriver.Pool} */
    let oraPool;
    /** @type {DBDriver.Connection} */
    let conn;
    try {
      try {
        oraPool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
      } catch(err) {
        // consume error since the pool might not be created yet
      }
      oraPool = oraPool || (await dlt.at.driver.createPool(dlt.at.pool.oracleConf));
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: ${dlt.at.connectionType} connection pool "${oraPool.poolAlias}" created with poolPingInterval=${oraPool.poolPingInterval} ` +
          `stmtCacheSize=${oraPool.stmtCacheSize} (${numSql} SQL files) poolTimeout=${oraPool.poolTimeout} poolIncrement=${oraPool.poolIncrement} ` +
          `poolMin=${oraPool.poolMin} poolMax=${oraPool.poolMax}`);
      }
      if (dlt.at.pingOnInit) {
        // validate by pinging connection from pool
        conn = await oraPool.getConnection();
        await conn.ping();
      }
      return oraPool;
    } catch (err) {
      recorder = errored(`sqler-oracle: ${oraPool ? 'Unable to ping connection from' : 'Unable to create'} connection pool`, dlt, null, err);
      throw err;
    } finally {
      if (conn) {
        await finalize(recorder, dlt, operation(dlt, 'close', false, conn, opts));
      }
    }
  }

  /**
   * Begins a transaction by opening a connection from the pool
   * @param {String} txId The transaction ID that will be started
   * @param {typedefs.SQLERTransactionOptions} opts The transaction options passed in via the public API
   * @returns {typedefs.SQLERTransaction} The transaction that was started
   */
  async beginTransaction(txId) {
    const dlt = internal(this);
    if (dlt.at.logger) {
      dlt.at.logger(`sqler-oracle: Beginning transaction ${txId} on connection pool "${dlt.at.pool.oracleConf.poolAlias}"`);
    }
    /** @type {typedefs.SQLERTransaction} */
    const tx = {
      id: txId,
      state: Object.seal({
        committed: 0,
        rolledback: 0,
        pending: 0,
        isReleased: false
      })
    };
    const pool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
    /** @type {OracleTransactionObject} */
    const txo = { tx, conn: await dlt.this.getConnection(pool, dlt.at.connConf) };
    /** @type {typedefs.SQLERExecOptions} */
    const opts = { transactionId: tx.id };
    const commit = operation(dlt, 'commit', true, txo, opts);
    tx.commit = async (isRelease) => {
      await commit();
      if (isRelease) await operation(dlt, 'close', true, txo, opts)();
    };
    const rollback = operation(dlt, 'rollback', true, txo, opts);
    tx.rollback = async (isRelease) => {
      await rollback();
      if (isRelease) await operation(dlt, 'close', true, txo, opts)();
    };
    Object.freeze(tx);
    dlt.at.transactions.set(txId, txo);
    return tx;
  }

  /**
   * Executes a SQL statement
   * @param {String} sql the SQL to execute
   * @param {OracleExecOptions} opts The execution options
   * @param {String[]} frags the frament keys within the SQL that will be retained
   * @param {typedefs.SQLERExecMeta} meta The SQL execution metadata
   * @param {(typedefs.SQLERExecErrorOptions | Boolean)} [errorOpts] The error options to use
   * @returns {typedefs.SQLERExecResults} The execution results
   */
  async exec(sql, opts, frags, meta, errorOpts) {
    /** @type {InternalFlightRecorder} */
    let recorder;
    const dlt = internal(this), numSql = opts.numOfPreparedFuncs;
    statementCacheSize(dlt, numSql); // &lt;- in case it changes from a manager.scan call or the cache expired
    /** @type {OracleTransactionObject} */
    const txo = opts.transactionId ? dlt.at.transactions.get(opts.transactionId) : null;
    /** @type {DBDriver.Connection} */
    let conn;
    /** @type {InternalExecMeta} */
    let execMeta;
    /** @type {DBDriver.Result} */
    let rslts;
    try {
      /** @type {typedefs.SQLERExecResults} */
      const rtn = {};

      // pseudo prepared statement for sqler API compliance
      if (opts.prepareStatement) {
        prepared(dlt, sql, opts, meta, txo, rtn);
      }

      if (opts.stream >= 0) { // streams handle prepared statements when streaming starts
        rslts = [ opts.type === 'READ' ? await createReadStream(dlt, sql, opts, meta, txo, rtn) : createWriteStream(dlt, sql, opts, meta, txo, rtn) ];
        rtn.rows = rslts;
        rtn.raw = rslts;
      } else {
        execMeta = createExecMeta(dlt, sql, opts);
        const pool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
        conn = txo ? null : await dlt.this.getConnection(pool, opts);
        rslts = await (txo ? txo.conn : conn).execute(execMeta.sql, execMeta.binds, execMeta.dopts.exec);

        if (txo) {
          if (opts.autoCommit) {
            await operation(dlt, 'commit', false, txo, opts)();
          } else {
            txo.tx.state.pending++;
            dlt.at.state.pending++;
          }
        }
        rtn.rows = rslts.rows;
        rtn.raw = rslts;
      }
      return rtn;
    } catch (err) {
      recorder = errored(`sqler-oracle: Failed to execute the following SQL:\n${sql}`, dlt, meta, err);
      throw err;
    } finally {
      if (conn) {
        await finalize(recorder, dlt, operation(dlt, 'close', false, conn, opts));
      }
    }
  }

  /**
   * Gets a new connection from the pool
   * @protected
   * @param {DBDriver.Pool} pool The connection pool
   * @param {OracleExecOptions} [opts] The execution options
   * @returns {DBDriver.Connection} The connection (when present)
   */
  async getConnection(pool, opts) {
    const dlt = internal(this);
    const hasDrvrOpts = opts &amp;&amp; !!opts.driverOptions;
    /** @type {DBDriver.PoolAttributes} */
    const poolAttrs = (hasDrvrOpts &amp;&amp; opts.driverOptions.pool) || {};
    poolAttrs.poolAlias = dlt.at.pool.oracleConf.poolAlias;
    return pool.getConnection(poolAttrs);
  }

  /**
   * Closes the Oracle connection pool
   * @returns {Number} The number of connections closed
   */
  async close() {
    const dlt = internal(this);
    try {
      /** @type {DBDriver.Pool} */
      let pool;
      try {
        pool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
      } catch (err) {
      }
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Closing connection pool "${dlt.at.pool.oracleConf.poolAlias}" ${statusLabel(dlt)}`);
      }
      if (pool) await pool.close();
      dlt.at.transactions.clear();
      dlt.at.state.pending = 0;
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Closed connection pool "${dlt.at.pool.oracleConf.poolAlias}" ${statusLabel(dlt)}`);
      }
      return dlt.at.state.pending;
    } catch (err) {
      errored(`sqler-oracle: Failed to close connection pool "${dlt.at.pool.oracleConf.poolAlias}" ${statusLabel(dlt)}`, dlt, null, err);
      throw err;
    }
  }

  /**
   * @returns {typedefs.SQLERState} The state
   */
  get state() {
    const dlt = internal(this);
    /** @type {DBDriver.Pool} */
    let pooled;
    try {
      pooled = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
    } catch (err) {
      pooled = {};
    }
    dlt.at.state.connections.count = pooled.connectionsOpen || 0;
    dlt.at.state.connections.inUse = pooled.connectionsInUse || 0;
    // use a copy for external use
    return JSON.parse(JSON.stringify(dlt.at.state));
  }

  /**
   * @protected
   * @returns {DBDriver} The `oracledb` driver module
   */
  get driver() {
    return internal(this).at.driver;
  }
}

module.exports = OracleDialect;

/**
 * Creates bind parameters suitable for SQL execution in Oracle
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {String} sql the SQL to execute
 * @param {OracleExecOptions} opts The execution options
 * @param {Object} [bindsAlt] An alternative to `opts.binds` that will be used
 * @returns {InternalExecMeta} The binds metadata
 */
function createExecMeta(dlt, sql, opts, bindsAlt) {
  /** @type {InternalExecMeta} */
  const rtn = {};
  const binds = bindsAlt || opts.binds;

  // interpolate and remove unused binds since
  // Oracle will throw "ORA-01036: illegal variable name/number" when unused bind parameters are passed (also, cuts down on payload bloat)
  rtn.bndp = dlt.at.track.interpolate({}, binds, dlt.at.driver, props => sql.includes(`:${props[0]}`));

  rtn.dopts = opts.driverOptions || {};
  rtn.dopts.exec = !!rtn.dopts &amp;&amp; rtn.dopts.exec ? dlt.at.track.interpolate({}, rtn.dopts.exec, dlt.at.driver) : {};
  rtn.dopts.exec.autoCommit = opts.autoCommit;
  if (!rtn.dopts.exec.hasOwnProperty('outFormat')) rtn.dopts.exec.outFormat = dlt.at.driver.OUT_FORMAT_OBJECT;

  rtn.sql = sql;
  rtn.binds = rtn.bndp;

  return rtn;
}

/**
 * Executes a function by name that resides on the Oracle connection
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {String} name The name of the function that will be called on the connection
 * @param {Boolean} [reset] Truthy to reset the pending connection and transaction count when the operation completes successfully
 * @param {(OracleTransactionObject | DBDriver.Connection)} txoOrConn Either the transaction object or the connection itself
 * @param {typedefs.SQLERExecOptions} [opts] The {@link typedefs.SQLERExecOptions}
 * @returns {Function} A no-arguement `async` function that returns the number or pending transactions
 */
function operation(dlt, name, reset, txoOrConn, opts) {
  return async () => {
    /** @type {InternalFlightRecorder} */
    let recorder = {};
    /** @type {OracleTransactionObject} */
    const txo = opts.transactionId &amp;&amp; txoOrConn.tx ? txoOrConn : null;
    /** @type {DBDriver.Connection} */
    const conn = txo ? txo.conn : txoOrConn;
    try {
      if (txo &amp;&amp; txo.tx.state.isReleased &amp;&amp; (name === 'commit' || name === 'rollback')) {
        return Promise.reject(new Error(`"${name}" already called on transaction "${txo.tx.id}"`));
      }
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Performing ${name} on connection pool "${dlt.at.pool.oracleConf.poolAlias}" ${statusLabel(dlt, null, txo)}`);
      }
      await conn[name]();
      if (txo) {
        if (name === 'commit') {
          txo.tx.state.committed++;
        } else if (name === 'rollback') {
          txo.tx.state.rolledback++;
        } else if (name === 'close' || name === 'release' /* release is depricated */) {
          txo.tx.state.isReleased = true;
        }
      }
      if (reset) {
        if (txo) dlt.at.transactions.delete(txo.tx.id);
        dlt.at.state.pending = 0;
      }
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Performed ${name} on connection pool "${dlt.at.pool.oracleConf.poolAlias}" ${statusLabel(dlt, null, txo)}`);
      }
    } catch (err) {
      recorder = errored(`sqler-oracle: Failed to ${name} ${dlt.at.state.pending} transaction(s) with options: ${
        opts ? JSON.stringify(Object.keys(opts)) : 'N/A'}`, dlt, null, err);
      throw err;
    } finally {
      if (name !== 'close' &amp;&amp; name !== 'release' /* release is depricated */ &amp;&amp; name !== 'end' &amp;&amp; ((recorder &amp;&amp; recorder.error) || (!txo &amp;&amp; conn))) {
        await finalize(recorder, dlt, operation(dlt, 'close', false, conn, opts));
      }
    }
    return dlt.at.state.pending;
  };
}

/**
 * Returns a label that contains connection details, transaction counts, etc.
 * @private
 * @param {InternalOracleDB} dlt The internal dialect object instance
 * @param {OracleExecOptions} [opts] Execution options that will be included in the staus label
 * @param {OracleTransactionObject} [txo] An optional transactiopn to add to the status label
 * @returns {String} The status label
 */
function statusLabel(dlt, opts, txo) {
  try {
    const state = dlt.at.state;
    return `(( ${opts ? `[ ${opts.name ? `name: ${opts.name}, ` : ''}type: ${opts.type} ]` : ''}[ uncommitted transactions: ${state.pending}${
      dlt.at.pool ? `, total connections: ${state.connections.count}, active connections: ${state.connections.inUse}` : ''} ]${
        txo ? ` - Transaction state: ${JSON.stringify(txo.tx.state)}` : ''} ))`;
  } catch (err) {
    if (dlt.at.errorLogger) {
      dlt.at.errorLogger('sqler-oracle: Failed to create status label', err);
    }
  }
}

/**
 * Creates a read stream that batches the read SQL executions
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {String} sql The SQL to execute.
 * @param {OracleExecOptions} opts The execution options
 * @param {typedefs.SQLERExecMeta} meta The SQL execution metadata
 * @param {OracleTransactionObject} [txo] The transaction object to use. When not specified, a connection will be established on the first write to the stream.
 * @param {typedefs.SQLERExecResults} rtn Where the _public_ prepared statement functions will be set (ignored when the read stream is not for a prepared
 * statement).
 * @returns {Stream.Readable} The created read stream
 */
async function createReadStream(dlt, sql, opts, meta, txo, rtn) {
  /** @type {Promise&lt;DBDriver.Connection>} */
  let connProm;
  /** @type {InternalFlightRecorder[]} */
  const recorders = [];
  const execMeta = createExecMeta(dlt, sql, opts);
  const pool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
  const conn = txo ? null : connProm ? await connProm : await (connProm = dlt.this.getConnection(pool, opts));
  const readable = (txo ? txo.conn : conn).queryStream(execMeta.sql, execMeta.binds, execMeta.dopts.exec);
  // dlt.at.track.readable(opts, readable);
  readable.on('error', async (err) => {
    if (err.sqlerOracle) return;
    recorders.push(errored(`sqler-oracle: An error occurred during ${Stream.Readable.name} streaming for SQL:\n${sql}`, dlt, meta, err));
  });
  readable.on('close', closeStreamHandler(dlt, sql, opts, meta, txo, () => connProm, readable, recorders));
  return readable;
}

/**
 * Creates a write stream that batches the write SQL executions
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {String} sql The SQL to execute
 * @param {OracleExecOptions} opts The execution options
 * @param {typedefs.SQLERExecMeta} meta The SQL execution metadata
 * @param {OracleTransactionObject} [txo] The transaction object to use. When not specified, a connection will be established on the first write to the stream.
 * @param {typedefs.SQLERExecResults} rtn Where the _public_ prepared statement functions will be set (ignored when the write stream is not for a prepared
 * statement).
 * @returns {Stream.Writable} The created write stream
 */
function createWriteStream(dlt, sql, opts, meta, txo, rtn) {
  /** @type {Promise&lt;DBDriver.Connection>} */
  let connProm;
  /** @type {InternalFlightRecorder[]} */
  const recorders = [];
  const writable = dlt.at.track.writable(opts, async (batch) => {
    try {
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Started ${Stream.Writable.name} stream execution for ${batch.length} batches ${statusLabel(dlt, opts, txo)}`);
      }
      const pool = dlt.at.driver.getPool(dlt.at.pool.oracleConf.poolAlias);
      const conn = txo ? txo.conn : connProm ? await connProm : await (connProm = dlt.this.getConnection(pool, opts));
      // batch all the binds into a single exectuion for a performance gain
      // https://oracle.github.io/node-oracledb/doc/api.html see connection.executeMany()
      let rslts, rslt;
      let bi = 0;
      const bindsArray = new Array(batch.length);
      /** @type {InternalExecMeta} */
      let execMeta;
      for (let binds of batch) {
        execMeta = createExecMeta(dlt, sql, opts, binds);
        // rslt = await conn.execute(execMeta.sql, execMeta.binds, execMeta.dopts.exec);
        // if (rslts) rslts.push(rslt);
        // else rslts = [ rslt ];
        bindsArray[bi] = execMeta.binds;
        bi++;
      }
      rslt = await conn.executeMany(execMeta.sql, bindsArray, execMeta.dopts.exec);
      if (rslts) {
        rslts.push(rslt);
      } else {
        rslts = Array.isArray(rslt) ? rslt : [ rslt ];
      }
      if (dlt.at.logger) {
        dlt.at.logger(`sqler-oracle: Completed execution of ${batch.length} batched write streams${
          execMeta.outs ? ` (with ${execMeta.outs.length} out binds)` : ''}`);
      }
      return rslts;
    } catch (err) {
      recorders.push(errored(`sqler-oracle: Failed to execute writable stream batch for ${
        batch ? batch.length : 'invalid batch'} on the following SQL:\n${sql}`, dlt, meta, err));
      throw err;
    }
  });
  writable.on('close' /* 'finish' */, closeStreamHandler(dlt, sql, opts, meta, txo, () => connProm, writable, recorders));
  return writable;
}

/**
 * Handles a `close` event on a stream by closing a connection (when passed), emitting the {@link typedefs.EVENT_STREAM_RELEASE} event and handling a transaction
 * `commit` (when a {@link OracleTransactionObject} is passed).
 * @private
 * @param {InternalOracleDB} dlt The internal dialect object instance
 * @param {String} sql The SQL to execute
 * @param {OracleExecOptions} opts The execution options
 * @param {typedefs.SQLERExecMeta} meta The SQL execution metadata
 * @param {OracleTransactionObject} [txo] The transaction object to use. When not specified, a connection will be established on the first write to the stream.
 * @param {Function} [getConn] An `async function()` to get the {@link DBDriver.Connection} that will be closed (ignored when a transaction is specified).
 * @param {(Stream.Readable | Stream.Writable)} stream The stream where the `close` event will be emitted.
 * @param {InternalFlightRecorder[]} recorders The flight recorders where the any errors will be recorded.
 * @returns {Function} An `async function()` that handles the `close` event on the specified stream
 */
function closeStreamHandler(dlt, sql, opts, meta, txo, getConn, stream, recorders) {
  const type = stream instanceof Stream.Readable ? Stream.Readable.name : stream instanceof Stream.Writable ? Stream.Writable.name : 'N/A';
  let isCommitted;
  return async () => {
    try {
      /** @type {DBDriver.Connection} */
      const conn = typeof getConn === 'function' ? await getConn() : null;
      if (conn) {
        await operation(dlt, 'close', false, conn, opts)();
        stream.emit(typedefs.EVENT_STREAM_RELEASE);
      }
      if (txo &amp;&amp; opts.autoCommit &amp;&amp; !recorders.length) {
        await operation(dlt, 'commit', false, txo, opts)();
        isCommitted = true;
        stream.emit(typedefs.EVENT_STREAM_COMMIT, txo.tx.id);
      } else if (txo) {
        txo.tx.state.pending++;
        dlt.at.state.pending++;
      }
    } catch (err) {
      recorders.push(errored(`sqler-oracle: Failed to handle ${type} stream close event for SQL:\n${sql}`, dlt, meta, err));
      stream.emit('error', recorders[recorders.length - 1].error);
    } finally {
      if (!isCommitted &amp;&amp; txo &amp;&amp; opts.autoCommit &amp;&amp; recorders.length) {
        await finalize(recorders, dlt, async () => {
          await operation(dlt, 'rollback', false, txo, opts)();
          stream.emit(typedefs.EVENT_STREAM_ROLLBACK, txo.tx.id);
        });
      }
    }
  };
}

/**
 * Either generates a prepared statement when it doesn't currently exist, or returns an existing prepared statement that waits for the original prepared statement
 * creation/connectivity/setup to complete before performing any executions.
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {String} sql The raw SQL to execute for the prepared statement
 * @param {OracleExecOptions} opts The execution options
 * @param {typedefs.SQLERExecMeta} meta The SQL execution metadata
 * @param {OracleTransactionObject} [txo] The transaction object to use. When not specified, a connection will be established.
 * @param {typedefs.SQLERExecResults} rtn The execution results used by the prepared statement where `unprepare` will be set
 * @returns {Object} The prepared statement
 */
function prepared(dlt, sql, opts, meta, txo, rtn) {
  rtn.unprepare = async () => {
    if (dlt.at.logger) {
      dlt.at.logger(`sqler-oracle: "unprepare" is a noop since Oracle implements the concept of statement caching instead (${
        meta.path
      }). See https://oracle.github.io/node-oracledb/doc/api.html#stmtcache`);
    }
  };
  return rtn;
}

/**
 * There is no prepare/unprepare since Oracle uses {@link https://oracle.github.io/node-oracledb/doc/api.html#stmtcache statement caching}.
 * Statement cache should account for the number of prepared functions/SQL files by a factor of `3x` to accomodate that many fragments in each SQL file.
 * @private
 * @param {InternalOracleDB} dlt The internal Oracle object instance
 * @param {Number} numSql The total number of SQL files used on the dialect
 * @returns {Number} The statement cache size
 */
function statementCacheSize(dlt, numSql) {
  dlt.at.pool.oracleConf.stmtCacheSize = (dlt.at.driverOptions &amp;&amp; dlt.at.driverOptions.stmtCacheSize) || ((numSql || 1) * 3);
  return dlt.at.pool.oracleConf.stmtCacheSize;
}

/**
 * Error handler
 * @private
 * @param {String} label A label to use to describe the error
 * @param {InternalOracleDB} dlt The internal dialect object instance
 * @param {typedefs.SQLERExecMeta} [meta] The SQL execution metadata
 * @param {Error} error An error that has occurred
 * @returns {InternalFlightRecorder} The flight recorder
 */
function errored(label, dlt, meta, error) {
  if (dlt.at.errorLogger) {
    dlt.at.errorLogger(label, error);
  }
  try {
    const pconf = Object.assign({}, dlt.at.pool.oracleConf);
    pconf.password = '***'; // mask sensitive data
    error.sqlerOracle = {
      message: label,
      poolConf: pconf,
      status: statusLabel(dlt)
    };
  } catch (err) {
    if (dlt.at.errorLogger) {
      dlt.at.errorLogger('sqler-oracle: Failed to capture error meta', err);
    }
  }
  return { error };
}

/**
 * Finally block handler
 * @private
 * @param {(InternalFlightRecorder | InternalFlightRecorder[])} [recorder] The flight recorder
 * @param {InternalOracleDB} dlt The internal dialect object instance
 * @param {Function} [func] An `async function()` that will be invoked in a catch wrapper that will be consumed and recorded when a flight recorder is
 * provided
 * @param {String} [funcErrorProperty=releaseError] A property name on the flight recorder error that will be set when the `func` itself errors
 * @returns {InternalFlightRecorder} The recorded error
 */
async function finalize(recorder, dlt, func, funcErrorProperty = 'releaseError') {
  // transactions/prepared statements need the connection to remain open until commit/rollback/unprepare
  if (typeof func === 'function') {
    try {
      await func();
    } catch (err) {
      if (recorder) {
        for (let rec of Array.isArray(recorder) ? recorder : [recorder]) {
          if (rec.error) recorder.error[funcErrorProperty] = err;
        }
      }
    }
  }
}

// private mapping
let map = new WeakMap();

/**
 * Internal state generator
 * @private
 * @param {DBDriver} dialect The dialect driver
 * @returns {InternalOracleDB} TThe internal dialect state
 */
let internal = function(dialect) {
  if (!map.has(dialect)) {
    map.set(dialect, {});
  }
  return {
    at: map.get(dialect),
    this: dialect
  };
};

/**
 * Oracle specific driver options
 * @typedef {Object} OracleDriverOptions
 * @property {Object} [global] An object that will contain properties set on the global `oracledb` module class. When a value is a string surrounded by `${}`,
 * it will be assumed to be a _constant_ property that resides on the `oracledb` module and will be interpolated accordingly.
 * For example `driverOptions.global.someProp = '${ORACLEDB_CONSTANT}'` will be interpolated as `oracledb.someProp = oracledb.ORACLEDB_CONSTANT`.
 * @property {Object} [pool] The pool `conf` options that will be passed into `oracledb.createPool({ conf })`. __Using any of the generic `pool.someOption`
 * will override the `conf` options set on `driverOptions.pool`.__ When a value is a string surrounded by `${}`, it will be assumed to be a _constant_
 * property that resides on the `oracledb` module and will be interpolated accordingly.
 * For example `driverOptions.pool.someProp = '${ORACLEDB_CONSTANT}'` will be interpolated as `pool.someProp = oracledb.ORACLEDB_CONSTANT`.
 * @property {Boolean} [pingOnInit=true] A truthy flag that indicates if a _ping_ will be performed after the connection pool is created when
 * {@link OracleDialect.init} is called.
 * @property {Boolean} [useTNS] Truthy to build a TNS `sql*net` connection string
 * @property {Number} [stmtCacheSize=numberOfSQLFiles * 3] The statement size that `oracledb` uses
 */

/**
 * Oracle specific extension of the {@link typedefs.SQLERConnectionOptions} from the [`sqler`](https://ugate.github.io/sqler/) module.
 * @typedef {Object} OracleConnectionOptionsType
 * @property {OracleDriverOptions} [driverOptions] The `oracledb` module specific options.
 * @typedef {typedefs.SQLERConnectionOptions &amp; OracleConnectionOptionsType} OracleConnectionOptions
 */

/**
 * Oracle specific extension of the execution options
 * @typedef {Object} OracleExecDriverOptions
 * @property {DBDriver.Pool} [pool] The pool attribute options passed into `oracledbPool.getConnection()`. When a value is a string surrounded by `${}`, it will be assumed
 * to be a _constant_ property that resides on the `oracledb` module and will be interpolated accordingly.
 * For example `driverOptions.pool.someProp = '${ORACLEDB_CONSTANT}'` will be interpolated as `pool.someProp = oracledb.ORACLEDB_CONSTANT`.
 * @property {(DBDriver.ExecuteOptions | DBDriver.ExecuteManyOptions)} [exec] The execution options passed into `oracledbConnection.execute()`.
 * __NOTE: `driverOptions.autoCommit` is ignored in favor of the universal `autoCommit` set directly on the {@link typedefs.SQLERExecOptions}.__
 * When a value is a string surrounded by `${}`, it will be assumed to be a _constant_ property that resides on the `oracledb` module and will be interpolated
 * accordingly.
 * For example `driverOptions.exec.someProp = '${ORACLEDB_CONSTANT}'` will be interpolated as `oracledbExecOpts.someProp = oracledb.ORACLEDB_CONSTANT`.
 * When streaming __writes__ using `execOpts.stream`, all executions are batched into `oracledb.Connection.executeMany` using `execOpts.stream` value as the batch size.
 * Therefore, a valid `exec.bindDefs` should be included as defined within the [oracldb documentation](https://oracle.github.io/node-oracledb/doc/api.html) when [DML
 * RETURNING](https://oracle.github.io/node-oracledb/doc/api.html#dml-returning-with-executemany).
 */

/**
 * Oracle specific extension of the {@link typedefs.SQLERExecOptions} from the [`sqler`](https://ugate.github.io/sqler/) module. When a property of `binds` contains
 * an object it will be _interpolated_ for property values on the `oracledb` module.
 * For example, `binds.name = { dir: '${BIND_OUT}', type: '${STRING}', maxSize: 40 }` will be interpolated as
 * `binds.name = { dir: oracledb.BIND_OUT, type: oracledb.STRING, maxSize: 40 }`.
 * @typedef {Object} OracleExecOptionsType
 * @property {OracleExecDriverOptions} [driverOptions] The `oracledb` module specific execution options.
 * @typedef {typedefs.SQLERExecOptions &amp; OracleExecOptionsType} OracleExecOptions
 */

/**
 * Transactions are wrapped in a parent transaction object so private properties can be added (e.g. prepared statements)
 * @typedef {Object} OracleTransactionObject
 * @property {typedefs.SQLERTransaction} tx The transaction
 * @property {DBDriver.Connection} conn The connection
 * @property {Map&lt;String, Function>} unprepares Map of prepared statement names (key) and no-argument _async_ functions that will be called as a pre-operation
 * call prior to `commit` or `rollback` (value)
 */

// ========================================== Internal Use ==========================================

/**
 * Internal database use
 * @typedef {Object} InternalOracleDB
 * @property {OracleDialect} this The dialect instance
 * @property {Object} at The internal dialect state
 * @property {typedefs.SQLERTrack} at.track The track
 * @property {DBDriver} at.driver The dialect driver
 * @property {Map&lt;String, OracleTransactionObject>} at.transactions The transactions map
 * @property {Object} at.pool The connection pool
 * @property {DBDriver.PoolAttributes} at.pool.oracleConf The `oracledb` pool attributes
 * @property {String} at.pool.alias The alias for the pool used to lookup the pool
 * @property {DBDriver.PoolAttributes} at.pool.conf The original/raw pool attributes
 * @property {typedefs.SQLERState} at.state The __global__ dialect state
 * @property {Function} [at.errorLogger] A function that takes one or more arguments and logs the results as an error (similar to `console.error`)
 * @property {Function} [at.logger] A function that takes one or more arguments and logs the results (similar to `console.log`)
 * @property {Boolean} [at.debug] A flag that indicates the dialect should be run in debug mode (if supported)
 * @property {Boolean} [at.pingOnInit] Truthy to ping when {@link OracleDialect.init}
 * @private
 */

/**
 * Metadata used inpreparation for execution.
 * @typedef {Object} InternalExecMeta
 * @property {OracleExecDriverOptions} dopts The formatted execution driver options.
 * @property {String} sql The formatted/bound execution SQL statement. Will also be set on `dopts.exec.sql` (when present).
 * @property {(Object | Array)} [binds] Either an object that contains the bind parameters as property names and property values as the bound values that can be
 * bound to an SQL statement or an `Array` of values format to support use of `?` parameter markers (non-prepared statements).
 * @property {Object} [bndp] The interpolated version of `opts.binds`.
 * @property {Object} [bindDefs] The properties within `binds` that are marked to be `oracledb.BIND_OUT`
 * @private
 */

/**
 * @typedef {Object} InternalFlightRecorder
 * @property {Error} [error] An errored that occurred
 * @property {DBDriver.Connection} [conn] A connection that will be `released` when an error exists
 * @private
 */</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v3.0.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://ugate.github.io/sqler-oracle/tree/v3.0.0">3.0.0</a> (2021-08-26)</h2>
<p><a href="https://ugate.github.io/sqler-oracle/compare/v2.1.0...v3.0.0">Full Changelog</a></p>
<p><strong>Features:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler-oracle/commit/7b85dbb57187647bb75b178b4d1e70bf02733782">[FEATURE]: Implemented sqler v9.0.0 read/write streaming and commit/rollback with optional connection release.</a></li>
</ul>
<p><strong>Fixes:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler-oracle/commit/0914bb91496f72f339860a6269e7d9df35e25db6">[FIX]: oracledb v5.1.0 -&gt; v5.2.0</a></li>
</ul>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>
