<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Usage - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
  <!-- https://realfavicongenerator.net/ -->
  
    <link
      
      rel="apple-touch-icon" 
      
      sizes="180x180" 
      
      href="apple-touch-icon.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="32x32" 
      
      href="favicon-32x32.png" 
      
    >
  
    <link
      
      rel="icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="favicon-16x16.png" 
      
    >
  
    <link
      
      rel="manifest" 
      
      href="site.webmanifest" 
      
    >
  
    <link
      
      rel="mask-icon" 
      
      type="image/png" 
      
      sizes="16x16" 
      
      href="safari-pinned-tab.svg" 
      
      color="#ffab40" 
      
    >
  
    <link
      
      type="text/css" 
      
      rel="stylesheet" 
      
      href="pkg-styles/pkg-style.css" 
      
    >
  

  
    <meta
      
      name="msapplication-TileColor" 
      
      content="#ffab40" 
      
    >
  
    <meta
      
      name="theme-color" 
      
      content="#bdbdbd" 
      
    >
  
    <meta
      
      name="viewport" 
      
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" 
      
    >
  

  <link type="text/css" rel="stylesheet" href="jsdocp/styles/index.css"></head>
<body><div id="jsdocpNav" class="jsdocp-remove-me pkg-menu"
  data-jsdocp-sm-position="bottom"
  data-jsdocp-md-position="bottom"
  data-jsdocp-lg-position="top"
  data-jsdocp-sm-match-media="(max-width: 480px)"
  data-jsdocp-md-match-media="(min-width: 481px) and (max-width: 839px)"
  data-jsdocp-lg-match-media="(min-width: 840px)"
  data-jsdocp-sm-auto-hide="true"
  data-jsdocp-md-auto-hide="true"
  data-jsdocp-lg-auto-hide="false">
  <a href="index.html" id="jsdocpLogo"
    title="sqler-oracle"
    class="jsdocp-logo ">
    <b class="pkg-logo">
    
      <?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg viewBox="0 0 29.26 29.26" y="0px" x="0px" version="1.1">
<g>
	<path
   d="M 3.2714844 12.164062 C 3.0504844 12.547062 2.921875 12.944422 2.921875 13.357422 L 2.921875 16.919922 C 2.921875 19.670922 8.1639531 21.902344 14.626953 21.902344 C 21.093953 21.902344 26.337891 19.670922 26.337891 16.919922 L 26.337891 13.357422 C 26.337891 12.944422 26.207375 12.547062 25.984375 12.164062 C 25.170706 13.571962 22.944745 14.736211 19.992188 15.388672 C 19.990472 16.830619 19.968304 18.235467 19.923828 18.3125 C 19.831308 18.472746 14.767068 21.396484 14.582031 21.396484 C 14.396995 21.396484 9.3327528 18.472746 9.2402344 18.3125 C 9.1955638 18.235128 9.175362 16.819813 9.1738281 15.371094 C 6.2660228 14.715075 4.0769893 13.558477 3.2714844 12.164062 z "
   />
	<path
   d="M14.627,23.31c-5.494,0-10.098-1.616-11.355-3.788c-0.221,0.381-0.35,0.779-0.35,1.191v3.564   c0,2.752,5.242,4.983,11.705,4.983c6.467,0,11.711-2.23,11.711-4.983v-3.564c0-0.412-0.131-0.81-0.354-1.19   C24.727,21.694,20.127,23.31,14.627,23.31z"
   />
	<path
   d="M 3.2402344 5.0429688 C 3.0392344 5.4089688 2.921875 5.7905937 2.921875 6.1835938 L 2.921875 9.7441406 C 2.921875 11.658469 5.4621005 13.319742 9.1816406 14.154297 C 9.1905174 13.111949 9.205954 12.203907 9.2402344 12.144531 C 9.3327524 11.984284 14.396995 9.0605469 14.582031 9.0605469 C 14.767068 9.0605469 19.83131 11.984284 19.923828 12.144531 C 19.958305 12.204246 19.975593 13.121262 19.984375 14.171875 C 23.754868 13.344294 26.337891 11.674559 26.337891 9.7441406 L 26.337891 6.1835938 C 26.337891 5.7905938 26.218578 5.4099687 26.017578 5.0429688 C 25.787578 7.0589688 20.785953 8.671875 14.626953 8.671875 C 8.4709531 8.671875 3.4692344 7.0579688 3.2402344 5.0429688 z "
   />
	<path
   d="M14.627,7.541c6.303,0,11.41-1.687,11.41-3.771c0-2.082-5.107-3.77-11.41-3.77   C8.328,0.001,3.219,1.689,3.219,3.771C3.219,5.854,8.328,7.541,14.627,7.541z"
   />
</g>
</svg>

    
    </b>
    <b id="jsdocpPkgName">sqler-oracle</b>
    <b>|</b>
    <hr/>
  </a>
  <a href="https://www.npmjs.com/package/sqler-oracle" id="jsdocpModule"
    title="npm"
    class="jsdocp-icon ">
    
    <svg version="1.1" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <g class="jsdocp-icon-svg-el pkg-icons" stroke="none" transform="translate(0,24) scale(0.1,-0.1)">
        <path d="M 0,120 0,0 l 120,0 120,0 0,120 0,120 -120,0 -120,0 z m 200,0 c 0,-73 0.23256,-80 0.23256,-80 0,0 -27.97435,0.741211 -40.61273,0.707427 C 159.61983,67.551504 160,70.949947 160,100 c 0,53 -2,60 -20,60 -18,0 -20,-7 -20,-60 l 0,-60 -40,0 -40,0 0,80 0,80 80,0 80,0 z"/>
      </g>
    </svg>
    
  </a>
  <a href="CHANGELOG.html" id="jsdocpChangelog" data-jsdocp-root-href="https://ugate.github.io/sqler-oracle/CHANGELOG.html"
    title="Changelog"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="64" width="64" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="M 29.896194,0.97873581 C 13.435048,0.97873581 1.1072664e-7,15.139296 0,32.489368 0,49.839439 13.435048,64 29.896194,64 46.357339,64 59.792385,49.839438 59.792388,32.489368 a 4.2273908,4.4556761 0 1 0 -8.453721,0 c -10e-7,12.534501 -9.550175,22.600399 -21.442473,22.600399 -11.892299,0 -21.4424739,-10.065899 -21.4424739,-22.600399 0,-12.5345 9.5501749,-22.6003988 21.4424739,-22.6003988 a 4.2273908,4.4556761 0 1 0 0,-8.91023339 z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 55.529412,24.680907 -8.470588,10.142582 16.941176,0 z"/>
      <rect class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        transform="matrix(0.6882785,0.72544656,-0.6882785,0.72544656,0,0)" y="-38.592953" x="38.592953" height="39.814472" width="11.375563" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 23.705056,39.295314 8.338477,-1.11407 -7.281487,-7.674698 z"/>
    </svg>
    
  </a>
  <a href="https://github.com/ugate/sqler-oracle.git" id="jsdocpSourceCode"
    title="Source Code"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 10 16" width="24" height="24" xmlns="http://www.w3.org/2000/svg" id="jsdocpSourceIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="evenodd"
        d="M8 1a1.993 1.993 0 0 0-1 3.72V6L5 8 3 6V4.72A1.993 1.993 0 0 0 2 1a1.993 1.993 0 0 0-1 3.72V6.5l3 3v1.78A1.993 1.993 0 0 0 5 15a1.993 1.993 0 0 0 1-3.72V9.5l3-3V4.72A1.993 1.993 0 0 0 8 1zM2 4.2C1.34 4.2.8 3.65.8 3c0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3 10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2zm3-10c-.66 0-1.2-.55-1.2-1.2 0-.65.55-1.2 1.2-1.2.65 0 1.2.55 1.2 1.2 0 .65-.55 1.2-1.2 1.2z"></path>
    </svg>
    <!-- GitHub icon -->
    <svg version="1.1" viewBox="0 0 16 16" height="24" width="24" xmlns="http://www.w3.org/2000/svg" class="jsdocp-remove-me" id="jsdocpGithubIcon">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none"  fill-rule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    </svg>
    
  </a>
  <!-- versions.json should point to the latest list -->
  <a id="jsdocpVersionsIcon"
    class="jsdocp-icon ">
    
    <svg version="1.1" viewBox="0 0 64 64" height="24" width="24" xmlns="http://www.w3.org/2000/svg">
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 63.999999,25.315556 -24.108295,0 9.74288,-10.026667 C 39.927261,5.6888885 24.210644,5.3333335 14.503322,14.933333 c -9.7073234,9.635555 -9.7073234,25.173334 0,34.808888 9.707322,9.635556 25.423939,9.635556 35.131262,0 4.835883,-4.764443 7.253823,-10.346666 7.253823,-17.386666 l 7.111592,0 c 0,7.039999 -3.1291,16.177777 -9.387301,22.364444 -12.480844,12.373334 -32.748879,12.373334 -45.2297224,0 -12.445286,-12.337778 -12.55196,-32.39111 -0.071116,-44.7288881 12.4808434,-12.3377774 32.4999734,-12.3377774 44.9808174,0 L 64,-5e-7 64,25.315556 Z" />
      <path class="jsdocp-icon-svg-el pkg-icons" stroke="none" fill-rule="nonzero"
        d="m 33.775734,17.777777 0,15.111111 12.445286,7.395556 -2.560173,4.302222 -15.218806,-9.031112 0,-17.777777 5.333693,0 z" />
    </svg>
    
  </a>
  <select id="jsdocpVersions"
    title="v3.0.0"
    data-jsdocp-version-base="/sqler-oracle"
    data-jsdocp-json-url="/sqler-oracle/versions.json"
    data-jsdocp-type=""
    data-jsdocp-from="1.0.0"
    data-jsdocp-version="3.0.0">
  </select>
</div>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Tutorials</li><li class="nav-item"><a href="tutorial-1-manual.html">Getting Started</a></li><li class="nav-item"><a href="tutorial-2-usage.html">Usage</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="OracleDialect.html">OracleDialect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#beginTransaction">beginTransaction</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#close">close</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#exec">exec</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#getConnection">getConnection</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="OracleDialect.html#init">init</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li>
</nav>

<div id="main">
    
    <h1 class="page-title">Usage</h1>
    

    <section>

<header>
    
</header>

<article>
    <h3>💡 <a href="https://www.oracle.com/database/">Oracle</a>/<a href="https://www.oracle.com/database/technologies/appdev/xe.html">Oracle XE (<strong>FREE</strong> Express Edition)</a> Examples (<a href="https://github.com/ugate/repo/tree/master/oracle#readme">see testing</a>):</h3>
<h4>Examples:<sub id="examples"></sub></h4>
<p>The examples below use the following setup:</p>
<p><strong><a href="https://ugate.github.io/sqler/typedefs.html#.SQLERPrivateOptions">Private Options Configuration:</a></strong> (appended to the subsequent connection options)</p>
<pre class="prettyprint source lang-json"><code>{
  &quot;univ&quot;: {
    &quot;db&quot;: {
      &quot;oracle&quot;: {
        &quot;host&quot;: &quot;sqler_oracle&quot;,
        &quot;username&quot;:&quot;SYSTEM&quot;,
        &quot;password&quot;: &quot;sqlerOracl3&quot;
      }
    }
  }
}
</code></pre>
<p><strong><a href="global.html#OracleConnectionOptions">Connection Options Configuration:</a></strong></p>
<pre class="prettyprint source lang-json"><code>{
  &quot;db&quot;: {
    &quot;dialects&quot;: {
      &quot;oracle&quot;: &quot;sqler-oracle&quot;
    },
    &quot;connections&quot;: [
      {
        &quot;id&quot;: &quot;oracle&quot;,
        &quot;name&quot;: &quot;oracle&quot;,
        &quot;dir&quot;: &quot;db/oracle&quot;,
        &quot;service&quot;: &quot;XE&quot;,
        &quot;dialect&quot;: &quot;oracle&quot;,
        &quot;pool&quot;: {
          &quot;min&quot;: 2,
          &quot;max&quot;: 2,
          &quot;increment&quot;: 0
        },
        &quot;driverOptions&quot;: {
          &quot;global&quot;: {
            &quot;maxRows&quot;: 0
          }
        }
      }
    ]
  }
}
</code></pre>
<p>Test code that illustrates how to use the Oracle database with various examples</p>
<pre class="prettyprint source lang-js"><code>// assuming &quot;conf&quot; contains combined &quot;univ&quot; and &quot;db&quot; objects from above

// create/initialize manager
const manager = new Manager(conf);
await manager.init();

// see subsequent examples for different examples
const result = await runExample(manager, 'oracle');

console.log('Result:', result);

// after we're done using the manager we should close it
process.on('SIGINT', async function sigintDB() {
  await manager.close();
  console.log('Manager has been closed');
});
</code></pre>
<!-- __Create Database:__<ins id="create_db"></ins>
```sql
-- db/oracle/setup/create.database.sql
BEGIN
  EXECUTE IMMEDIATE 'CREATE USER sqlerora IDENTIFIED BY 1234';
  EXECUTE IMMEDIATE 'CREATE SCHEMA AUTHORIZATION sqlerora';
END;
```
```js
``` -->
<p><strong>Create Table(s):</strong><ins id="create_tables"></ins></p>
<pre class="prettyprint source lang-jsdocp"><code>-- db/oracle/setup/create.table1.sql
'use strict';

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  // create the database and/or schema
  return manager.db[connName].setup.create.database();
};
</code></pre>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/setup/create.table2.sql
CREATE TABLE TEST2 (&quot;ID&quot; INTEGER NOT NULL PRIMARY KEY, &quot;NAME&quot; VARCHAR2(512), &quot;REPORT&quot; BLOB, &quot;CREATED_AT&quot; TIMESTAMP WITH TIME ZONE, &quot;UPDATED_AT&quot; TIMESTAMP WITH TIME ZONE)
</code></pre>
<pre class="prettyprint source lang-js"><code>'use strict';

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  // create the tables (in parallel)
  return Promise.all([
    manager.db[connName].setup.create.table1(),
    manager.db[connName].setup.create.table2()
  ]);
};
</code></pre>
<p><strong>Create Rows:</strong><ins id="create"></ins></p>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/create.table1.rows.sql
INSERT INTO TEST (ID, &quot;NAME&quot;, CREATED_AT, UPDATED_AT)
VALUES (:id, :name, :created, :updated)
</code></pre>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/create.table2.rows.sql
INSERT INTO TEST2 (ID, NAME, REPORT, CREATED_AT, UPDATED_AT)
VALUES (:id2, :name2, EMPTY_BLOB(), :created2, :updated2)
RETURNING REPORT INTO :report2
</code></pre>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');
const Fs = require('fs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  const date = new Date();
  /** @type {typedefs.SQLERExecResults[]} */
  const rtn = new Array(2);

  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction
    tx = await manager.db[connName].beginTransaction();

    // Insert rows (implicit transactions)
    rtn[0] = await manager.db[connName].create.table1.rows({
      name: 'TX Table 1 (ROWS CREATE)', // name is optional
      autoCommit: false, // transaction needs to span the INSERT and LOB/stream
      transactionId: tx.id, // ensure execution takes place within transaction
      binds: {
        // illustrates the use of Oracle specific binds
        // (sqler will interpolate &quot;${SOME_NAME}&quot; into &quot;oracledb.SOME_NAME&quot;)
        // alt would be &quot;id: 1&quot; and &quot;name: 'TABLE: 1, ROW: 1'&quot;
        id: {
          val: 1,
          type: '${NUMBER}',
          dir: '${BIND_IN}'
        },
        name: {
          val: 'TABLE: 1, ROW: 1, CREATE: &quot;Initial creation&quot;',
          dir: '${BIND_INOUT}',
          maxSize: 500
        },
        created: date,
        updated: date
      }
    });
    rtn[1] = await manager.db[connName].create.table2.rows({
      name: 'TX Table 2 (ROWS CREATE)', // name is optional
      autoCommit: false, // transaction needs to span the INSERT and pipe()
      transactionId: tx.id, // ensure execution takes place within transaction
      binds: {
        id2: 1,
        name2: 'TABLE: 2, ROW: 1, CREATE: &quot;Initial creation&quot;',
        // tell Oracle that a LOB is inbound - SQL using &quot;RETURNING INTO&quot;
        // (for small files, contents can be directly set on report2)
        report2: { type: '${BLOB}', dir: '${BIND_OUT}' },
        created2: date,
        updated2: date
      }
    });

    // wait until inbound streaming of report2 LOB has been completed
    await streamLobFromFile(rtn[1], 'report2', './test/files/audit-report.png');

    // commit the transaction
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // rollback the transaction
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }

  return rtn;
};

/**
 * Streams a LOB from a file path into an `oracledb.Lob` instance
 * @param {typedefs.SQLERExecResults} rslt The `sqler` results that contains the Oracle
 * `rslt.raw.outBinds`
 * @param {String} name The inbound LOB parameter name that will be streamed
 * @param {String} pathToLOB The LOB file path to stream
 * @returns {typedefs.SQLERExecResults} The passed results
 */
async function streamLobFromFile(rslt, name, pathToLOB) {
  // raw Oracle &quot;outBinds&quot; should contain the bind parameter name
  if (!rslt.raw.outBinds || !rslt.raw.outBinds[name] || !rslt.raw.outBinds[name][0]) {
    throw new Error(`Missing RETURNING INTO statement for LOB streaming SQL for &quot;${name}&quot;?`);
  }
  // for &quot;type: '${BLOB}', dir: '${BIND_OUT}'&quot;, Oracle returns a stream
  const lob = rslt.raw.outBinds[name][0];
  await pipeline(
    Fs.createReadStream(pathToLOB),
    lob
  );
  return rslt
}
</code></pre>
<p><strong>Read Rows:</strong><ins id="read"></ins></p>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/read.table1.rows.sql
SELECT TST.ID AS &quot;id&quot;, TST.NAME AS &quot;name&quot;, -- EMPTY_CLOB() AS &quot;report&quot;,
TST.CREATED_AT AS &quot;created&quot;, TST.UPDATED_AT AS &quot;updated&quot;
FROM TEST TST
WHERE UPPER(TST.NAME) LIKE CONCAT(CONCAT('%', UPPER(:name)), '%') 
</code></pre>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/read.table2.rows.sql
SELECT TST2.ID AS &quot;id&quot;, TST2.NAME AS &quot;name&quot;, TST2.REPORT AS &quot;report&quot;,
TST2.CREATED_AT AS &quot;created&quot;, TST2.UPDATED_AT AS &quot;updated&quot;
FROM TEST2 TST2
WHERE UPPER(TST2.NAME) LIKE CONCAT(CONCAT('%', UPPER(:name)), '%')
</code></pre>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');
const Os = require('os');
const Fs = require('fs');

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {
  /** @type {typedefs.SQLERExecResults[]} */
  const rtn = new Array(2);

  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction (needed to keep LOB stream open)
    tx = await manager.db[connName].beginTransaction();

    // read from multiple tables
    rtn[0] = manager.db[connName].read.table1.rows({ binds: { name: 'table' } });
    rtn[1] = manager.db[connName].read.table2.rows({
      autoCommit: false, // transaction needs to span the life of the LOB stream
      transactionId: tx.id, // ensure execution takes place within transaction
      binds: { name: 'table' }
    });
    rtn[0] = await rtn[0];
    rtn[1] = await rtn[1];

    // write report to file?
    const writeProms = [];
    for (let row of rtn[1].rows) {
      if (row.report) {
        // store the path to the report (illustrative purposes only)
        row.reportPath = `${Os.tmpdir()}/sqler-${connName}-read-${row.id}.png`;
        writeProms.push(streamLobToFile(row.report, row.reportPath));
      }
    }
    if (writeProms.length) {
      await Promise.all(writeProms);
    }

    // commit the transaction
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // rollback the transaction
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }

  return { rows: [ ...rtn[0].rows, ...rtn[1].rows ] };
};

/**
 * Streams a LOB `oracledb.Lob` instance into a file
 * @param {Object} lob The outbound LOB parameter name that will be streamed
 * @param {String} pathToLOB The LOB file path to stream
 * @returns {Promise} The LOB to file promise
 */
 function streamLobToFile(lob, pathToLOB) {
  return new Promise((resolve, reject) => {
    const writeStream = Fs.createWriteStream(pathToLOB);
    writeStream.on('error', (err) => lob.destroy(err));
    lob.on('close', () => resolve());
    lob.on('end', () => lob.destroy());
    lob.on('error', (err) => reject(err));
    lob.pipe(writeStream);
  });
}
</code></pre>
<p><strong>Update Rows:</strong><ins id="update"></ins></p>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/update.table1.rows.sql
UPDATE TEST
SET NAME = :name, UPDATED_AT = :updated
WHERE ID = :id
</code></pre>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/update.table2.rows.sql
UPDATE TEST2
SET NAME = :name2, UPDATED_AT = :updated2
WHERE ID = :id2
</code></pre>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  const date = new Date();

  // binds
  const table1BindsArray = [
    {
      id: 1, name: '', updated: date
    }
  ];
  const table2BindsArray = [
    {
      id2: 1, name2: '', updated2: date
    }
  ];
  const rtn = {};

  //-------------------------------------------------------
  // There are two different ways to perform a transaction
  // 1. Implicit (suitable for a single execution per tx)
  // 2. Explicit (suitable for multiple executions per tx)

  //-------------------------------------------------------
  // There are two different ways to perform a transaction
  // 1. Implicit (suitable for a single execution per tx)
  // 2. Explicit (suitable for multiple executions per tx)

  // using implicit transactions:
  await implicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using an explicit transaction:
  await explicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using a prepared statement:
  await preparedStatementUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using a prepared statement within an explicit transaction
  await preparedStatementExplicitTxUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  return rtn;
};

async function implicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // returned results for both tables
  rtn.txImpRslts = new Array(table1BindsArray.length + table2BindsArray.length);

  // simple iterator over all the binds
  forEach('UPDATE', 'Implicit transaction', table1BindsArray, table2BindsArray, (idx, ti, ri, binds, nameProp) => {

    // Example concurrent execution using an implicit transaction for
    // each SQL execution (autoCommit = true is the default)
    rtn.txImpRslts[idx] = manager.db[connName].update[`table${ti + 1}`].rows({
      name: binds[nameProp], // execution name is optional
      binds
    });

  });

  // could have also ran is series by awaiting when the SQL function is called
  for (let i = 0; i &lt; rtn.txImpRslts.length; i++) {
    rtn.txImpRslts[i] = await rtn.txImpRslts[i];
  }
}

async function explicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // returned results for both tables
  rtn.txExpRslts = new Array(table1BindsArray.length + table2BindsArray.length);
  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction
    tx = await manager.db[connName].beginTransaction();

    // simple iterator over all the binds
    forEach('UPDATE_TX', 'Explicit transaction', table1BindsArray, table2BindsArray, (idx, ti, ri, binds, nameProp) => {

      // Example concurrent execution (same transacion)
      rtn.txExpRslts[idx] = manager.db[connName].update[`table${ti + 1}`].rows({
        name: binds[nameProp], // execution name is optional
        binds,
        autoCommit: false,
        transactionId: tx.id, // ensure execution takes place within transaction
      });

    });
  
    // could have also ran is series by awaiting when the SQL function is called
    for (let i = 0; i &lt; rtn.txExpRslts.length; i++) {
      rtn.txExpRslts[i] = await rtn.txExpRslts[i];
    }

    // commit the transaction
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // rollback the transaction
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }
}

// NOTE: Prepared statements are a noop since Oracle implements the concept of statement caching instead
// See https://oracle.github.io/node-oracledb/doc/api.html#-313-statement-caching
// Example just for illustration of consistent sqler API functionality
async function preparedStatementUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // need to keep track of at least one result for each table so that unprepare can be called on each
  // (could call unprepare using any of the returned execution results for each table)
  let psRsltIndexTable1 = 0, psRsltIndexTable2;
  // returned results for both tables
  rtn.psRslts = new Array(table1BindsArray.length + table2BindsArray.length);
  try {

    // simple iterator over all the binds
    forEach('UPDATE_PS', 'Prepred statement', table1BindsArray, table2BindsArray, (idx, ti, ri, binds, nameProp) => {

      // Example concurrent execution (same transacion)
      rtn.psRslts[idx] = manager.db[connName].update[`table${ti + 1}`].rows({
        name: binds[nameProp], // execution name is optional
        // flag the SQL execution as a prepared statement
        prepareStatement: true,
        // include the bind parameters
        binds
      });

      // need to keep track of at least one result for each table so that unprepare can be called on each
      if (ti && !psRsltIndexTable2) psRsltIndexTable2 = ti;

    });

    // wait for concurrent executions to complete
    for (let i = 0; i &lt; rtn.psRslts.length; i++) {
      rtn.psRslts[i] = await rtn.psRslts[i];
    }
  } finally {
    // since prepareStatement = true, we need to close the statement
    // and release the prepared statement connection back to the pool
    // (also drops the temporary stored procedure that executes the prepared statement)
    const proms = [];
    if (rtn.psRslts[psRsltIndexTable1]) proms.push(rtn.psRslts[psRsltIndexTable1].unprepare());
    if (rtn.psRslts[psRsltIndexTable2]) proms.push(rtn.psRslts[psRsltIndexTable2].unprepare());
    if (proms.length) await Promise.all(proms);
  }
}

// NOTE: Prepared statements are a noop since Oracle implements the concept of statement caching instead
// See https://oracle.github.io/node-oracledb/doc/api.html#-313-statement-caching
// Example just for illustration of consistent sqler API functionality
async function preparedStatementExplicitTxUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // returned results for both tables
  rtn.txExpPsRslts = new Array(table1BindsArray.length + table2BindsArray.length);
  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction
    tx = await manager.db[connName].beginTransaction();

    // simple iterator over all the binds
    forEach('UPDATE_PS_TX', `Prepred statement with txId ${tx.id}`, table1BindsArray, table2BindsArray, (idx, ti, ri, binds, nameProp) => {

      // Example execution in concurrent (same transacion)
      rtn.txExpPsRslts[idx] = manager.db[connName].update[`table${ti + 1}`].rows({
        name: binds[nameProp], // execution name is optional
        autoCommit: false, // don't auto-commit after execution
        transactionId: tx.id, // ensure execution takes place within transaction
        prepareStatement: true, // ensure a prepared statement is used
        // include the bind parameters
        binds
      });

    });

    // wait for concurrent executions to complete
    for (let i = 0; i &lt; rtn.txExpPsRslts.length; i++) {
      rtn.txExpPsRslts[i] = await rtn.txExpPsRslts[i];
    }

    // unprepare will be called when calling commit
    // (alt, could have called unprepare before commit)
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // unprepare will be called when calling rollback
      // (alt, could have called unprepare before rollback)
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }
}

// just a utility function to iterate over muliple bind arrays and update bind names
function forEach(name, label, table1BindsArray, table2BindsArray, itemHandler) {
  const ln = table1BindsArray.length + table2BindsArray.length;
  for (let i = 0, ti, ri, barr, nameProp; i &lt; ln; i++) {
    // select which table the binds are for
    if (i &lt; table1BindsArray.length) {
      ti = 0;
      ri = i;
      barr = table1BindsArray;
    } else {
      ti = 1;
      ri = i - table1BindsArray.length;
      barr = table2BindsArray;
    }
    nameProp = `name${ti ? ti + 1 : ''}`;

    // update with expanded name
    barr[ri][nameProp] = `TABLE: ${ti + 1}, ROW: ${ri + 1}, ${name}: &quot;${label} ${i + 1}&quot;`;

    itemHandler(i, ti, ri, barr[ri], nameProp);
  }
}
</code></pre>
<p><strong>Delete Rows:</strong><ins id="delete"></ins></p>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/delete.table1.rows.sql
DELETE FROM TEST
WHERE ID = :id
</code></pre>
<pre class="prettyprint source lang-sql"><code>-- db/oracle/delete.table2.rows.sql
DELETE FROM TEST2
WHERE ID = :id2
</code></pre>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  /** @type {typedefs.SQLERExecResults[]} */
  const rtn = new Array(2);

  // delete rows (implicit transactions)
  rtn[0] = await manager.db[connName].delete.table1.rows({
    binds: { id: 1 }
  });
  rtn[1] = await manager.db[connName].delete.table2.rows({
    binds: { id2: 1 }
  });

  return rtn;
};
</code></pre>
<p><strong>Create Rows (streaming using the same SQL as the <a href="#create">prior create rows example</a>):</strong><ins id="create_stream"></ins></p>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');
const Fs = require('fs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  const date = new Date();

  const bindsArray = [
    [
      {
        id: 100, name: 'TABLE: 1, ROW: 1, CREATE_STREAM: &quot;Initial creation&quot;', created: date, updated: date
      },
      {
        id: 200, name: 'TABLE: 1, ROW: 2, CREATE_STREAM: &quot;Initial creation&quot;', created: date, updated: date
      },
    ],
    [
      {
        id2: 100, name2: 'TABLE: 2, ROW: 1, CREATE_STREAM: &quot;Initial creation&quot;', created2: date, updated2: date,
        report2: null // see report2 in bindDefs
      },
      {
        id2: 200, name2: 'TABLE: 2, ROW: 2, CREATE_STREAM: &quot;Initial creation&quot;', created2: date, updated2: date,
        report2: null // see report2 in bindDefs
      },
    ]
  ];
  // since table2 is using oracledb.BIND_OUT for streaming column data,
  // there needs to be a bind definitions set on &quot;driverOptions.exec&quot;
  // https://oracle.github.io/node-oracledb/doc/api.html#executemanyoptbinddefs
  // https://oracle.github.io/node-oracledb/doc/api.html#oracledbconstantsbinddir
  const driverOptsArray = [
    {
      exec: {
        dmlRowCounts: true // output of the number of rows affected by each input data record
      }
    },
    {
      exec: {
        dmlRowCounts: true, // output of the number of rows affected by each input data record
        bindDefs: {
          id2: { type: '${NUMBER}' },
          name2: { type: '${STRING}', maxSize: 512 },
          created2: { type: '${DATE}' },
          updated2: { type: '${DATE}' },
          // tell Oracle that a LOB is inbound - SQL using &quot;RETURNING INTO&quot;
          // (for small files, contents can be directly set on report2 as STRING)
          report2: { type: '${BLOB}', dir: '${BIND_OUT}' }
        }
      }
    }
  ];
  // write column stream file would typically be from different files
  const reportsArray = [
    './test/files/audit-report.png',
    './test/files/audit-report.png'
  ];
  /** @type {typedefs.SQLERExecResults[]} */
  const rslts = new Array(bindsArray.length);

  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction
    tx = await manager.db[connName].beginTransaction();

    for (let ti = 0; ti &lt; bindsArray.length; ti++) {
      // Insert rows into multiple tables within a single execution
      rslts[ti] = await manager.db[connName].create[`table${ti + 1}`].rows({
        // create binds will be batched in groups of 2 before streaming them to the database since
        // execOpts.stream = 2, but we could have batched them individually (stream = 1) as well
        // https://oracle.github.io/node-oracledb/doc/api.html#executemany
        stream: 2,
        autoCommit: false, // transaction needs to span the INSERT and pipe()
        transactionId: tx.id, // ensure execution takes place within transaction
        driverOptions: driverOptsArray[ti]
        // no need to set execOpts.binds since they will be streamed from the create instead
      });

      let proms = ti ? new Array(rslts[ti].rows.length) : null;
      for (let writeStream of rslts[ti].rows) {
        // when the batched results come in, stream the lob into the report
        if (ti) {
          writeStream.on(typedefs.EVENT_STREAM_BATCH, async (batch) => {
            for (let rslt of batch) {
              proms.push(streamLobFromFile(rslt, 'report2', reportsArray));
            }
          });
        }

        await pipeline(
          // here we're just using some static values for illustration purposes, but they can come from a
          // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
          // into JSON binds before the sqler writable stream receives them
          Stream.Readable.from(bindsArray[ti]),
          writeStream
        );

        if (proms && proms.length) {
          // wait until inbound streaming of report2 LOB has been completed
          await Promise.all(proms);
        }
      }
    }

    // commit the transaction
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // rollback the transaction
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }

  return rslts;
};

/**
 * Streams a LOB from a file path into an `oracledb.Lob` instance
 * @param {typedefs.SQLERExecResults} rslt The `sqler` results that contains the Oracle
 * `rslt.raw.outBinds`
 * @param {String} name The inbound LOB parameter name that will be streamed
 * @param {(String | String[])} pathsToLOB The LOB file path(s) to stream
 * @returns {typedefs.SQLERExecResults} The passed results
 */
async function streamLobFromFile(rslt, name, pathsToLOB) {
  const outs = Array.isArray(rslt.outBinds) ? rslt.outBinds : [ rslt.outBinds ];
  const pths = Array.isArray(pathsToLOB) ? pathsToLOB : [ pathsToLOB ];
  let oi = 0, proms = new Array(outs.length);
  for (let out of outs) {
    // raw Oracle &quot;outBinds&quot; should contain the bind parameter name
    if (!out || !out[name] || !out[name][0]) {
      throw new Error(`Missing RETURNING INTO statement for LOB streaming SQL for &quot;${name}&quot;?`);
    }
    // for &quot;type: '${BLOB}', dir: '${BIND_OUT}'&quot;, Oracle returns a stream
    const lob = out[name][0];
    proms[oi] = pipeline(
      Fs.createReadStream(pths[oi]),
      lob
    );
    oi++;
  }
  await Promise.all(proms);
  return rslt;
}
</code></pre>
<p><strong>Read Rows (streaming using the same SQL as the <a href="#read">prior read rows example</a>):</strong><ins id="read_stream"></ins></p>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');
const Os = require('os');
const Fs = require('fs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  /** @type {typedefs.SQLERExecResults[]} */
  const rtn = new Array(2);

  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction (needed to keep LOB stream open)
    tx = await manager.db[connName].beginTransaction();

    // stream all reads to a central JSON file (illustrative purposes only)
    rtn.jsonFile = `${Os.tmpdir()}/sqler-${connName}-read-stream-all.json`;

    let count = 0;
    for (let ti = 0; ti &lt; rtn.length; ti++) {
      // read from multiple tables
      rtn[ti] = await manager.db[connName].read[`table${ti + 1}`].rows({
        stream: 1, // indicate reads will be streamed
        binds: { name: 'stream' }
      });

      // write binary report buffer to file?
      for (let readStream of rtn[ti].rows) {
        // read stream is Oracle implementation:
        // https://oracle.github.io/node-oracledb/doc/api.html#querystream
        await pipeline(
          readStream,
          new Stream.Transform({
            objectMode: true,
            transform: async function transformer(chunk, encoding, callback) {
              try {
                count++;
                if (chunk.report instanceof Stream.Readable) {
                  await streamLobToFile(connName, chunk.report, chunk);
                }
                callback(null, chunk);
              } catch (err) {
                callback(err, chunk);
              }
            }
          }),
          // add a transform that formats the JSON into an array string suitable for file write
          async function* transformStringify(chunksAsync) {
            yield `${ti ? ',' : '['}`;
            let cnt = -1;
            for await (const chunk of chunksAsync) {
              cnt++;
              yield `${cnt ? ',' : ''}${JSON.stringify(chunk)}`;
            }
            yield `${ti && cnt ? ']' : ''}`;
          },
          Fs.createWriteStream(rtn.jsonFile, { flags: ti ? 'a' : 'w' })
        );
      }
      
      // when nothing is written make sure the JSON file is empty (illustrative purposes only)
      if (!count) {
        Fs.promises.writeFile(rtn.jsonFile, '[]');
      }
    }
  
    // commit the transaction
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // rollback the transaction
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }

  return { rows: [ ...rtn[0].rows, ...rtn[1].rows ], jsonFile: rtn.jsonFile };
};

/**
 * Streams a LOB `oracledb.Lob` instance into a file
 * @param {String} connName The connection name that will be included in the written file name
 * @param {Object} lob The outbound LOB parameter name that will be streamed
 * @param {Object} chunk The LOB owning object
 * @returns {Promise} The LOB to file promise
 */
function streamLobToFile(connName, lob, chunk) {
  return new Promise((resolve, reject) => {
    // don't include the report in the JSON since there should be a file
    delete chunk.report;
    // stream the report into a file (illustrative purposes only)
    chunk.reportPath = `${Os.tmpdir()}/sqler-${connName}-read-${chunk.id}.png`;
    const writeStream = Fs.createWriteStream(chunk.reportPath);
    writeStream.on('error', (err) => lob.destroy(err));
    lob.on('close', () => resolve());
    lob.on('end', () => lob.destroy());
    lob.on('error', (err) => reject(err));
    lob.pipe(writeStream);
  });
}
</code></pre>
<p><strong>Update Rows (streaming using the same SQL as the <a href="#update">prior update rows example</a>):</strong><ins id="update_stream"></ins></p>
<pre class="prettyprint source lang-js"><code>'use strict';

const typedefs = require('sqler/typedefs');
const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  const date = new Date();

  // binds
  const table1BindsArray = [
    {
      id: 100, name: '', updated: date
    },
    {
      id: 200, name: '', updated: date
    },
  ];
  const table2BindsArray = [
    {
      id2: 100, name2: '', updated2: date
    },
    {
      id2: 200, name2: '', updated2: date
    }
  ];
  const rtn = {};

  //-------------------------------------------------------
  // There are two different ways to perform a transaction
  // 1. Implicit (suitable for a single execution per tx)
  // 2. Explicit (suitable for multiple executions per tx)

  // using implicit transactions:
  await implicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using an explicit transaction:
  await explicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using a prepared statement:
  await preparedStatementUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  // Using a prepared statement within an explicit transaction
  await preparedStatementExplicitTxUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray);

  return rtn;
};

async function implicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // simply rename all the bind names to reflect the action being performed
  nameAll('UPDATE_STREAM', 'Implicit transaction', table1BindsArray, table2BindsArray);

  // loop through and perform the updates via the writable stream
  let ni = 0;
  const bindsArrays = [ table1BindsArray, table2BindsArray ];
  rtn.txImpRslts = new Array(bindsArrays.length);
  for (let bindsArray of bindsArrays) {
    // Example using an implicit transaction for each streamed (autoCommit = true is the default)
    rtn.txImpRslts[ni] = await manager.db[connName].update[`table${ni + 1}`].rows({
      // update binds will be batched in groups of 1 before streaming them to the database since
      // execOpts.stream = 1, but we could have batched them in groups (stream = 2) as well
      // https://oracle.github.io/node-oracledb/doc/api.html#executemany
      stream: 1
      // no need to set execOpts.binds since they will be streamed from the update instead
    });
    
    // now that the write streams are ready and the read binds have been renamed,
    // we can cycle through the bind arrays and write them to the appropriate tables
    for (let writeStream of rtn.txImpRslts[ni].rows) {
      await pipeline(
        // here we're just using some static values for illustration purposes, but they can come from a
        // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
        // into JSON binds before the sqler writable stream receives them
        Stream.Readable.from(bindsArray),
        writeStream
      );
    }
    ni++;
  }
}

async function explicitTransactionUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // start a transaction
  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    tx = await manager.db[connName].beginTransaction();

    // simply rename all the bind names to reflect the action being performed
    nameAll('UPDATE_STREAM_TX', 'Explicit transaction', table1BindsArray, table2BindsArray);

    // loop through and perform the updates via the writable stream
    let ni = 0;
    const bindsArrays = [ table1BindsArray, table2BindsArray ];
    rtn.txExpRslts = new Array(bindsArrays.length);
    for (let bindsArray of bindsArrays) {
      // Example using an implicit transaction for each streamed (autoCommit = true is the default)
      rtn.txExpRslts[ni] = await manager.db[connName].update[`table${ni + 1}`].rows({
        autoCommit: false, // don't auto-commit after execution
        transactionId: tx.id, // ensure execution takes place within transaction
        // update binds will be batched in groups of 1 before streaming them to the database since
        // execOpts.stream = 1, but we could have batched them in groups (stream = 2) as well
        // https://oracle.github.io/node-oracledb/doc/api.html#executemany
        stream: 1
        // no need to set execOpts.binds since they will be streamed from the update instead
      });
      
      // now that the write streams are ready and the read binds have been renamed,
      // we can cycle through the bind arrays and write them to the appropriate tables
      for (let writeStream of rtn.txExpRslts[ni].rows) {
        await pipeline(
          // here we're just using some static values for illustration purposes, but they can come from a
          // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
          // into JSON binds before the sqler writable stream receives them
          Stream.Readable.from(bindsArray),
          writeStream
        );
      }
      ni++;
    }

    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }
}

async function preparedStatementUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  // need to keep track of at least one result for each table so that unprepare can be called on each
  // (could call unprepare using any of the returned stream results for each table)
  let psRsltTable1, psRsltTable2;
  try {
    // simply rename all the bind names to reflect the action being performed
    nameAll('UPDATE_STREAM_PS', 'Prepared statement', table1BindsArray, table2BindsArray);

    // loop through and perform the updates via the writable stream
    let ni = 0;
    const bindsArrays = [ table1BindsArray, table2BindsArray ];
    rtn.psRslts = new Array(bindsArrays.length);
    for (let bindsArray of bindsArrays) {
      // Example using an implicit transaction for each streamed (autoCommit = true is the default)
      rtn.psRslts[ni] = await manager.db[connName].update[`table${ni + 1}`].rows({
        // prepared statement flag does not really do anything, but to show universal sqler API use
        // https://oracle.github.io/node-oracledb/doc/api.html#stmtcache
        prepareStatement: true,
        // update binds will be batched in groups of 1 before streaming them to the database since
        // execOpts.stream = 1, but we could have batched them in groups (stream = 2) as well
        // https://oracle.github.io/node-oracledb/doc/api.html#executemany
        stream: 1
        // no need to set execOpts.binds since they will be streamed from the update instead
      });

      // need to keep track of at least one result for each table so that unprepare can be called on each
      if (ni === 0 && !psRsltTable1) {
        psRsltTable1 = rtn.psRslts[ni];
      } else if (ni && !psRsltTable2) {
        psRsltTable2 = rtn.psRslts[ni];
      }

      // now that the write streams are ready and the read binds have been renamed,
      // we can cycle through the bind arrays and write them to the appropriate tables
      for (let writeStream of rtn.psRslts[ni].rows) {
        await pipeline(
          // here we're just using some static values for illustration purposes, but they can come from a
          // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
          // into JSON binds before the sqler writable stream receives them
          Stream.Readable.from(bindsArray),
          writeStream
        );
      }
      ni++;
    }
    
  } finally {
    // since prepareStatement = true, we need to close the statement
    // and release the prepared statement connection back to the pool
    // (also drops the temporary stored procedure that executes the prepared statement)
    const proms = [];
    if (psRsltTable1) proms.push(psRsltTable1.unprepare());
    if (psRsltTable2) proms.push(psRsltTable2.unprepare());
    if (proms.length) await Promise.all(proms);
  }
}

async function preparedStatementExplicitTxUpdate(manager, connName, rtn, table1BindsArray, table2BindsArray) {
  /** @type {typedefs.SQLERTransaction} */
  let tx;
  try {
    // start a transaction
    tx = await manager.db[connName].beginTransaction();

    // simply rename all the bind names to reflect the action being performed
    nameAll('UPDATE_STREAM_PS_TX', `Prepared statement with txId ${tx.id}`, table1BindsArray, table2BindsArray);

    // loop through and perform the updates via the writable stream
    let ni = 0;
    const bindsArrays = [ table1BindsArray, table2BindsArray ];
    rtn.txExpPsRslts = new Array(bindsArrays.length);
    for (let bindsArray of bindsArrays) {
      // Example using an implicit transaction for each streamed (autoCommit = true is the default)
      rtn.txExpPsRslts[ni] = await manager.db[connName].update[`table${ni + 1}`].rows({
        autoCommit: false, // don't auto-commit after execution
        transactionId: tx.id, // ensure execution takes place within transaction
        // prepared statement flag does not really do anything, but to show universal sqler API use
        // https://oracle.github.io/node-oracledb/doc/api.html#stmtcache
        prepareStatement: true,
        // update binds will be batched in groups of 1 before streaming them to the database since
        // execOpts.stream = 1, but we could have batched them in groups (stream = 2) as well
        // https://oracle.github.io/node-oracledb/doc/api.html#executemany
        stream: 1
        // no need to set execOpts.binds since they will be streamed from the update instead
      });
  
      // now that the write streams are ready and the read binds have been renamed,
      // we can cycle through the bind arrays and write them to the appropriate tables
      for (let writeStream of rtn.txExpPsRslts[ni].rows) {
        await pipeline(
          // here we're just using some static values for illustration purposes, but they can come from a
          // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
          // into JSON binds before the sqler writable stream receives them
          Stream.Readable.from(bindsArray),
          writeStream
        );
      }
      ni++;
    }

    // unprepare will be called on all prepared statements associated with the transaction when calling
    // commit (alt, could have called unprepare before commit)
    await tx.commit(true); // true to release the connection back to the pool
  } catch (err) {
    if (tx) {
      // unprepare will be called on all prepared statements associated with the transaction when calling
      // rollback (alt, could have called unprepare before rollback)
      await tx.rollback(true); // true to release the connection back to the pool
    }
    throw err;
  }
}

// just a utility function to iterate over muliple bind arrays and rename them
function nameAll(name, label, table1BindsArray, table2BindsArray) {
  const ln = table1BindsArray.length + (table2BindsArray ? table2BindsArray.length : 0);
  for (let i = 0, ti, ri, barr; i &lt; ln; i++) {
    // select which table the binds are for
    if (i &lt; table1BindsArray.length) {
      ti = 0;
      ri = i;
      barr = table1BindsArray;
    } else {
      ti = 1;
      ri = i - table1BindsArray.length;
      barr = table2BindsArray;
    }
    // update with expanded name
    barr[ri][`name${ti ? ti + 1 : ''}`] = `TABLE: ${ti + 1}, ROW: ${ri + 1}, ${name}: &quot;${label} ${i + 1}&quot;`;
  }
  return [ 'name', 'name2' ];
}
</code></pre>
<p><strong>Delete Rows (streaming using the same SQL as the <a href="#delete">prior delete rows example</a>):</strong><ins id="delete_stream"></ins></p>
<pre class="prettyprint source lang-js"><code>'use strict';

const Stream = require('stream');
// node >= v16 :
// const { pipeline } = require('stream/promises');
// node &lt; 16 :
const Util = require('util');
const pipeline = Util.promisify(Stream.pipeline);

// export just to illustrate module usage
module.exports = async function runExample(manager, connName) {

  /** @type {typedefs.SQLERExecResults[]} */
  const rtn = new Array(2);

  for (let ti = 0; ti &lt; rtn.length; ti++) {
    // Delete rows from multiple tables within a single execution
    rtn[ti] = await manager.db[connName].delete[`table${ti + 1}`].rows({
      // delete binds will be batched in groups of 2 before streaming them to the database since
      // execOpts.stream = 2, but we could have batched them individually (stream = 1) as well
      // https://oracle.github.io/node-oracledb/doc/api.html#executemany
      stream: 2
      // no need to set execOpts.binds since they will be streamed from the delete instead
    });

    for (let writeStream of rtn[ti].rows) {
      await pipeline(
        // here we're just using some static values for illustration purposes, but they can come from a
        // any readable stream source like a file, database, etc. as long as they are &quot;transformed&quot;
        // into JSON binds before the sqler writable stream receives them
        Stream.Readable.from([
          {
            [`id${ti ? 2 : ''}`]: 100
          },
          {
            [`id${ti ? 2 : ''}`]: 200
          }
        ]),
        writeStream
      )
    }
  }

  return rtn;
};
</code></pre>
<!-- __Delete Database:__<ins id="delete_db"></ins>
```sql
-- db/oracle/setup/delete.database.sql
DROP SCHEMA sqlerora
```
```jsdocp ./test/lib/oracle/setup/delete.database.js
``` -->
</article>

</section>

</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<div id="jsdocpChangelogContent" data-title="CHANGELOG v3.0.0">
  <svg class="jsdocp-close" id="jsdocpChangelogClose" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
  </svg>
  <h2><a href="https://ugate.github.io/sqler-oracle/tree/v3.0.0">3.0.0</a> (2021-08-26)</h2>
<p><a href="https://ugate.github.io/sqler-oracle/compare/v2.1.0...v3.0.0">Full Changelog</a></p>
<p><strong>Features:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler-oracle/commit/7b85dbb57187647bb75b178b4d1e70bf02733782">[FEATURE]: Implemented sqler v9.0.0 read/write streaming and commit/rollback with optional connection release.</a></li>
</ul>
<p><strong>Fixes:</strong></p>
<ul>
<li><a href="https://ugate.github.io/sqler-oracle/commit/0914bb91496f72f339860a6269e7d9df35e25db6">[FIX]: oracledb v5.1.0 -&gt; v5.2.0</a></li>
</ul>
</div>



<script src="jsdocp/scripts/index.js"></script></body>
</html>